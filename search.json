[{"title":"微服务概览","url":"/2022/04/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88/","content":"前言很多时候，我们更多的时间在业务上，每天都在干着CRDU的活，但是我们是工程师，不是在写一个demo，能跑起来就万事大吉。\n我们更多时候要去思考，要站在一个工程的角度来思考，写的接口流量大了要怎么写，怎么测试，怎么持续集成，怎么自动化部署，整个系统，怎么样才算稳定，怎样才算得上企业级应用？\n这些需要扎实的基础，长久的沉淀的经验，和一课持续学习的内心。\n很多时候我们没那么多机会去接触到这么庞大的架构，那么这个时候，去学前人的经验，是个不错的选择。\n而且，真正到面试的时候，除非你是刚入行的小白，一般语言层面的面试内容都不多，除非找茬，语言层面的问题一般都不会特别难。 相反一个精明的面试官会更多去问你一些关于工程方面的问题，一些实际经验，抛出一些具体的突发情况，你怎么去思考，去排查解决问题的思路如何。\n所以对于这种关于工程方面的方法论，我们今天就开始聊这些。\n微服务概览\n微服务的核心是组件服务化\n\n单体架构 (巨石应用)尽管也是模块化逻辑，但是最终它还是会打包并部署为单体应用，其中最主要的问题就是这个应用太复杂，以至于任何单个开发者都不可能完全搞懂他。\n导致应用无法扩展，可靠性很低，最终，敏捷开发和部署无法完成！\n\n如上图，浏览器通过简单的apache负载均衡，所有请求直接落到web后端，然后请求mysql。\n所有的后端代码都在一坨，部署在一台服务器。巨石架构！\n拆分\n化繁为简，分而治之\n\n按照功能，拆分成粒度更小的服务\n\nSOA(面向服务)的架构体系\n拆分后的特点:\n\n每个服务独占一个DB，从通路的角度来讲，单DB不可能无限扩容。DB直接的通信就使用HTTP&#x2F;RPC\n\n\nSOA(面向服务)的架构体系和微服务之间的关系\n可以理解为微服务是SOA的一种实践\n\n本质上都是面向服务的架构设计模式，只不过微服务更小一点\n小就是美服务小，意味着代码少，bug也少，易于测试，易于维护，也容易不断迭代完善，直到精致而美妙\n一般来说，小的服务，一个开发人员可以维护1~2个，甚至更多\n单一职责一个服务只需要做好一件事，专注才能做好\n函数也好，类也好，服务也好，我们一直强调单一职责，也就是尽可能只做一件事情。\n就比如我们经常会写common这样的包,啥都往里面塞，其实不是一个很好的风格。最后common就成了“关东煮”，啥都有。\n\n虽然实现单一职责很难，而且过度追求单一职责也会导致代码阅读性降低。这个博弈需要开发人员的经验和追求。\n\n尽可能早的创建原型可能早的提供服务API，建立服务契约，达成服务之间沟通的一致性约定，至于实现和完善可以慢慢做\n\n微服务之间尽早定义API这个很关键\n\n可移植性比效率重要服务间的轻量级交互协议在效率和可移植性二者之间，首要依然要考虑兼容性和可移植性\n微服务的定义\n围绕业务功能构建的，服务关注单一职责，服务间采用轻量级的通信机制，可以用全自动部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活\n\n从设计模式上来说，关注单一职责，围绕业务功能，采用分治思想，化繁为简。\n从网络通信的角度，采用轻量可靠的通信机制。保证通信效率和稳定性\n从工程的角度来说, 独立部署，自动化部署，可以移植性高，不是强依赖语言依赖生态\n原子服务也就是单一职责\n如果不知道怎么划分服务，不了解业务。那么一开始，按照功能来拆！先拆粗的，等后面了解了，在细分。比如账号服务，比如订单服务，比如积分服务。这些都很容易想到\n\n先粗粒度的拆分服务，后期在慢慢演进，迭代\n\n一般来说，一个服务尽可能关注到一个业务闭环作为一个服务。在初期是比较合适的。\n独立进程每一个微服务都是一个独立的进程，容器编排。\n独立进程就更好的实现隔离部署。\n隔离部署去中心化治理微服务缺点\n微服务不是万能的！\n\n基础设施的建设，复杂度高\n以前只有一个服务，现在成了100个服务，架构超级复杂，画图都不一定能画出来。\n可能你根据链路追踪啊啥的，能画出最终的架构图，服务之间的依赖特别多，如果有人破坏测试环境，就炸了\n特别是排障的时候，以前一个服务的时候，看看日志就大多能找到问题，现在服务多了，排障就相对困难，而且对基建的要求也很高\n\n分布式系统给，必定会带来固有的复杂性，开发者不得不使用RPC或者消息传递，来实现进程之间的通信，此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效的问题\n\n\n分区的数据库架构，同时更新多个业务主体的事务很普遍，这种事务对于单体架构应用来说很容易，因为只有一个数据库，但是在微服务架构中，需要更新不同服务所使用到的不同数据库，从而对开发者提出了更多的要求和更高的挑战\n\n\n测试一个基于微服务架构的 应用也是一个很复杂的任务\n\n\n服务模块之间的依赖，应用的升级可能会设计到多个模块的修改，可能会出现连锁故障\n\n\n对运维的基础设施的挑战也很大，这么多应用是不是要上k8s，日志要收集，指标要统计，监控是不是要升级，报警是不是要做起来了…..\n\n以前代码写得烂，可能也就对数据库有点压力，但是网络通信的成本很低\n但是现在RPC了，比如循环调用一个微服务30次，可能上游服务也有调用其他服务，所以下游的请求，可能会被放大。导致基层服务压力过大\n比如，获取一个文章下的前30个人的评论列表方式一：for循环调用请求30次(一定会放大请求的！)KVM 虚拟化的 pps == 30万，每一秒，发30万个包方式二： 调用一个批量接口\n\n\n所以尽可能提供粗粒度的批量接口\n尽可能避免服务之间的串行调用\n\n组件服务化传统实现组件的方式是通过库(library),库是和应用一起运行在进程中的，库的局部变化，意味着整个应用的重新部署。\n通过服务来实现组件，意味着将应用拆散为一系列的服务，运行子啊不同的进程中，那么单一服务的局部变化只需要重新部署对应服务的进程\n首先需要有一个kit,也就是基础框架。比如springCloud,go kit ,go micro,gin\n然后我们必须有服务了，service&#x3D; 业务代码+ kit依赖+第三方依赖组成的业务微服务\n轻量级通讯： rpc + message queue（消息队列来实现： 同步请求&#x2F;异步请求）\n\n 本质上等同于，多个业务域(domain)由多个微服务组合(compose)完成一个完整的用户场景(useCase),他是一个面向场景的API设计\n\n按业务组织服务\n康威定律\n\n按业务能力组织服务的意思:服务提供的能力和业务功能对应\n比如： 订单服务和数据访问服务，订单服务反应了真实的订单相关业务，数据服务是一种技术抽象服务，不反应真实的业务。\n\n事实上传统应用设计架构的分层结构正反应了不同角色的沟通。所以，若要按微服务的方式来构建应用，也需要对团队的组织架构做调整。每个服务背后的小团队的组织是夸功能的，包含实现业务所需的全面技能。\n推荐组织架构管理\nyou build it ,you fix it 开发人员直接对生产负责，最终为这个业务场景，交互负责\n\n开发人员要自己测试，因为没有人比你更熟悉自己写的代码  ownership 要有主人翁意识\n\n\n而不是烟囱式的开发\n\n烟囱式开发讲究只覆盖自己的职能范围。\n微服务是鼓励闭环团队的！\n大前端团队 &gt; 网关接入 &gt; 业务服务 &gt; 平台服务 &gt; 基础设施(PASS&#x2F;SASS)\n去中心化每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案，但也要避免过度多样化，结合团队实际情况来做取舍，要是每个服务都用不同的语言技术栈来实现，维护成本也高\n\n数据去中心化\n治理去中心话(很多环节容易出现流量热点)\n技术去中心化\n\n\n每个服务独享自身的数据存储设施(缓存，数据库等)，有利于服务的独立性，隔离相关干扰\n\n基础设施自动化无自动化不微服务，自动化包括测试和部署。\n单一进程的传统应用被拆分为一系列的多进程服务后，意味着，开发，调试，测试，监控和部署的复杂度都会相应增加。必须要有合适的自动化基础设施来支持微服务架构模式，否则，开发，运维的成本将大大增加\nCICD: gitlab + gitlab hooks + k8s\nTesting: 测试环境，单元测试，API自动化测试(yapi)\n在线运行时: K8s，以及一系列Prometheus,ELK,Conrtol Panle\n可用性 &amp; 兼容性设计一定要有一个Desigin For Failure的思想\n# 你不要相信任何人，所有你写的东西，你依赖的东西，可能都会炸，都会出事# 你写的每一行代码都有可能error！# 抱着这样的决心去写代码。你代码质量不会低到哪里去\n\n微服务架构采用粗粒度的进程通信，引入二外的复杂性和需要处理的新问题，比如网络延迟，消息格式，负载均衡和容错。。。。忽略其中任何一点都属于对“分布式计算的误解”\n\n隔离\n超时控制\n负载保护\n限流\n降级\n重试\n负载均衡\n\n一旦采用了微服务架构模式，那么在服务需要变更时候，我们需要格外小心！\n服务提供者的变更可能引发服务消费者的兼容性破坏。\n\n时刻谨记保持服务契约(接口)的兼容性\n\nBe conservative in what you send, be liberal in what you accept.\n\n发送要保守，接收要开放\n\n按照博斯塔尔法的思想来设计和实现服务，发送数据时候要更加保守，意味着最小化的传递必要信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性！\n“找对象要求不要太高，但是要足够包容对象的小缺点。”【暖渣的终极奥义】\n总结","tags":["微服务"]},{"title":"go语言map底层原理","url":"/2022/04/13/go%E8%AF%AD%E8%A8%80map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","content":"知识点\n如果以下这些知识点你都懂，那么这篇文章对你意义不大\n\n\n解决哈希冲突的常用办法有哪些？ GO 语言中 Map 底层是使用那种方式解决哈希冲突的？\nmap 底层是怎么实现渐进式扩容的？\nmap 底层数据结构是什么样子的？\nmap 是线程安全的吗？\nmap 是有序的吗？\n\n","categories":["go语言"],"tags":["go基础"]},{"title":"go语言slice底层原理","url":"/2022/04/13/go%E8%AF%AD%E8%A8%80slice%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","content":"知识点\nslice 会内存泄漏吗？\nslice 是值类型和是引用类型？\nslice 是线程安全的吗？\nslice 扩容策略？\n能不能按照 slice 扩容的策略，写一个”缩容算法” ?\n\n1 slice 和 数组的区别1.1 数组\n数组是只能 保存相同类型元素 的 不可变长 的 占用连续内存 的数据结构\n\n所以数组的三个显著特点:\n\n\n只能保存相同的元素 (对于强类型语言来说还合理，但是对于python这种动态语言来说也不是很友好)\n不可边长(意味着创建数组就必须合理估计数组长度，创建完成后不会再改变)\n占用连续内存(意味着通过下标可以快速定位到对应元素，效率极高)\n\n\n数组长度是其类型的一部分！比如[1]string和[2]string就是两个不同的数组类型\n数组的弊端也十分明显，特别是固定长度，导致开发的时候很不灵活。所以很多语言都实现了动态数组。 go 也不例外，slice 就是基于数组实现的动态数组。\n但是 slice 也是有一堆坑的(有舍有得嘛)。今天我们好扯扯！\n1.2 slice\n\n\n\n数组\n切片\n\n\n\n\n值类型\n引用类型\n\n\n\n定长(长度是数组类型的一部分)\n边长\n\n\n\n\n\n\n\n2 slice 的雷区本文来自 煎鱼大佬的博客: https://eddycjy.com/posts/go/slice-discuss/\n猜猜下面的代码运行结果:\nfunc main() &#123;\tsl := make([]int, 0, 10)  // 创建切片 sl 长度为 0，容量为 10\tvar appenFunc = func(s []int) &#123;\t\ts = append(s, 10, 20, 30)\t\tfmt.Println(s)\t&#125;\tfmt.Println(sl)\tappenFunc(sl)\tfmt.Println(sl)\tfmt.Println(sl[:10])&#125;\n\n\nhttps://eddycjy.com/posts/go/slice-leak/\n3 slice 的底层原理slice 的源码在runtime&#x2F;slice.go\n// A notInHeapSlice is a slice backed by go:notinheap memory.type notInHeapSlice struct &#123;\tarray *notInHeap    // 指向底层数组的指针     --&gt;&gt;  元素存哪里 ? \tlen   int           // 长度                --&gt;&gt;  已经存了多少元素 ? \tcap   int           // 容量                --&gt;&gt;  一共可以存多少元素 ?&#125;\n从源码可知， slice &#x3D; 指向底层数组的指针 + 长度  + 容量\n关键问题: slice 实际存储数据的地方，还是一个数组\nslice 坑就坑在不同 slice 可以共用一片底层数组！参考https://eddycjy.com/posts/go/slice-discuss/\nhttps://eddycjy.com/posts/go/slice-leak/\n","categories":["go语言"],"tags":["go基础"]}]